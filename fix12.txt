Problem: pdf-parse library tries to load a test file ./test/data/05-versions-space.pdf on initialization, which doesn't exist in the Vercel serverless environment.

Solution: Create a custom wrapper that bypasses the test file requirement.

Step 1: Create a custom PDF parser wrapper

File: lib/pdfParser.ts

// Custom PDF parser that bypasses pdf-parse's test file requirement
import fs from 'fs';
import path from 'path';

export async function parsePDF(buffer: Buffer): Promise<string> {
  // Dynamically require the internal pdf-parse modules directly
  // This bypasses the index.js which tries to load the test file
  
  const PDFJS = await import('pdfjs-dist/legacy/build/pdf.mjs');
  
  // Disable worker
  PDFJS.GlobalWorkerOptions.workerSrc = '';
  
  const data = new Uint8Array(buffer);
  
  try {
    const doc = await PDFJS.getDocument({
      data,
      useSystemFonts: true,
      disableFontFace: true,
      verbosity: 0,
    }).promise;
    
    let fullText = '';
    
    for (let i = 1; i <= doc.numPages; i++) {
      const page = await doc.getPage(i);
      const textContent = await page.getTextContent();
      
      const pageText = textContent.items
        .filter((item: any) => 'str' in item)
        .map((item: any) => item.str)
        .join(' ');
      
      fullText += pageText + '\n';
    }
    
    return fullText.trim();
  } catch (error: any) {
    throw new Error('Failed to parse PDF: ' + error.message);
  }
}
Step 2: Update the API route to use the custom parser

File: app/api/extract-text/route.ts

import { NextRequest, NextResponse } from 'next/server';

async function extractPDFText(buffer: Buffer): Promise<string> {
  // Use pdfjs-dist directly without pdf-parse
  // @ts-ignore
  const PDFJS = await import('pdfjs-dist/legacy/build/pdf.mjs');
  
  const data = new Uint8Array(buffer);
  
  const doc = await PDFJS.getDocument({
    data,
    useSystemFonts: true,
    disableFontFace: true,
    verbosity: 0,
  }).promise;
  
  let fullText = '';
  
  for (let i = 1; i <= doc.numPages; i++) {
    const page = await doc.getPage(i);
    const textContent = await page.getTextContent();
    
    const pageText = textContent.items
      .filter((item: any) => 'str' in item)
      .map((item: any) => item.str)
      .join(' ');
    
    fullText += pageText + '\n';
  }
  
  return fullText.trim();
}

export async function POST(req: NextRequest) {
  try {
    const formData = await req.formData();
    const file = formData.get('file') as File;

    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 });
    }

    const fileName = file.name.toLowerCase();
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    let text = '';

    if (fileName.endsWith('.txt')) {
      text = buffer.toString('utf-8');
      
    } else if (fileName.endsWith('.docx')) {
      const mammoth = await import('mammoth');
      const result = await mammoth.extractRawText({ buffer });
      text = result.value;
      
    } else if (fileName.endsWith('.pdf')) {
      text = await extractPDFText(buffer);
      
    } else {
      return NextResponse.json(
        { error: 'Unsupported format. Use PDF, DOCX, or TXT.' },
        { status: 400 }
      );
    }

    // Clean text
    text = text.replace(/\s+/g, ' ').replace(/\n{3,}/g, '\n\n').trim();

    if (!text || text.length < 20) {
      return NextResponse.json(
        { error: 'Could not extract text from file. It may be image-based or empty.' },
        { status: 400 }
      );
    }

    return NextResponse.json({ 
      success: true, 
      text,
      characterCount: text.length,
    });
    
  } catch (error: any) {
    console.error('Extraction error:', error);
    return NextResponse.json(
      { error: 'Failed to process file: ' + error.message },
      { status: 500 }
    );
  }
}
Step 3: Remove pdf-parse and ensure pdfjs-dist is installed

npm uninstall pdf-parse
npm install pdfjs-dist
Step 4: Update frontend to use server-side extraction for all files

In app/linkedin-optimizer/page.tsx, app/interview-prep/page.tsx, and app/generate/page.tsx:

Update the handleFileUpload function:

const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
  const file = e.target.files?.[0];
  if (!file) return;

  setResumeFile(file);
  setError('');

  const formData = new FormData();
  formData.append('file', file);

  try {
    const response = await fetch('/api/extract-text', {
      method: 'POST',
      body: formData,
    });

    const data = await response.json();

    if (response.ok && data.success) {
      setResumeContent(data.text);
    } else {
      setError(data.error || 'Failed to extract text from file');
    }
  } catch (err: any) {
    console.error('Upload error:', err);
    setError('Failed to process file. Please try again.');
  }
};
Step 5: Delete the lib/pdfExtractor.ts file if it exists (we're not using client-side extraction anymore)

rm lib/pdfExtractor.ts
Git commands:

npm uninstall pdf-parse
npm install pdfjs-dist
git add .
git commit -m "Fix: Use pdfjs-dist directly for PDF extraction, remove pdf-parse"
git push origin main
Summary:

Before	After
Used pdf-parse which requires test files	Use pdfjs-dist directly
Test file error on Vercel	No test file dependency
Complex fallback logic	Simple, single approach
This solution uses pdfjs-dist directly on the server without the problematic pdf-parse wrapper. This is the same library that pdf-parse uses internally, but without the test file requirement.